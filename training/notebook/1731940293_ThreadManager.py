import uuid
import threading
from collections import deque
from typing import Dict, Any, List
import torch
import logging
from torch_geometric.data import Data
import pybullet as p
import pybullet_data
import numpy as np

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

class ThreadManager:
    """
    ThreadManager serves as the central authority for managing thread locks and facilitating secure
    communication between user objects within the simulation environment. It employs a sophisticated
    hashing mechanism that amalgamates unique identifiers from both the object itself and the blockchain
    infrastructure to generate secure tokens required for executing thread-safe operations.

    Attributes:
        locks (Dict[str, threading.Lock]): A mapping of object IDs to their corresponding thread locks,
                                           ensuring synchronized access during updates.
        mailboxes (Dict[str, deque]): A mapping of object IDs to their respective message queues, acting
                                      as virtual mailboxes for inter-object communication.
        tokens (Dict[str, str]): A mapping of object IDs to their current security tokens, generated by
                                  hashing the combination of the object's UUID, blockchain UUID, and the
                                  most recent timestamp.
        manager_lock (threading.Lock): A global lock safeguarding the internal state of the ThreadManager,
                                       preventing race conditions during token generation and lock assignments.
    """

    def __init__(self):
        """
        Initializes the ThreadManager with empty mappings for locks, mailboxes, and tokens.
        Establishes a global manager lock to protect internal state during concurrent access.
        """
        self.locks: Dict[str, threading.Lock] = {}
        self.mailboxes: Dict[str, deque] = {}
        self.tokens: Dict[str, str] = {}
        self.manager_lock = threading.Lock()

    def register_object(self, object_id: str):
        """
        Registers a new user object with the ThreadManager. This involves creating a dedicated thread
        lock and mailbox for the object, and generating an initial security token by hashing the
        object's UUID with a blockchain-related UUID and the current timestamp.

        Args:
            object_id (str): The unique identifier of the user object to be registered.
        """
        with self.manager_lock:
            if object_id not in self.locks:
                self.locks[object_id] = threading.Lock()
                self.mailboxes[object_id] = deque()
                # Generate a unique blockchain-related UUID for the object
                blockchain_uuid = str(uuid.uuid4())
                # Combine object UUID, blockchain UUID, and current thread name for hashing
                combined_string = f"{object_id}-{blockchain_uuid}-{threading.current_thread().name}"
                # Securely hash the combined string to produce the initial token
                token = uuid.uuid5(uuid.NAMESPACE_DNS, combined_string).hex
                self.tokens[object_id] = token
                logger.info(f"Registered object '{object_id}' with initial token '{token}'.")

    def acquire_lock(self, object_id: str, token: str) -> bool:
        """
        Attempts to acquire the thread lock for a specified user object using the provided token.
        The token is a hashed combination of the object's UUID, blockchain UUID, and the latest timestamp,
        ensuring that only authorized entities can perform update operations.

        Args:
            object_id (str): The unique identifier of the user object requesting the lock.
            token (str): The security token provided by the user object for authentication.

        Returns:
            bool: True if the lock is successfully acquired, False otherwise.
        """
        with self.manager_lock:
            current_token = self.tokens.get(object_id)
            if current_token == token:
                lock = self.locks.get(object_id)
                if lock and lock.acquire(blocking=False):
                    logger.info(f"Lock acquired for object '{object_id}' with token '{token}' without blocking.")
                    return True
                elif lock and lock.acquire(blocking=True):
                    logger.info(f"Lock acquired for object '{object_id}' with token '{token}' with blocking.")
                else:
                    logger.warning(f"Lock for object '{object_id}' is already held.")
            else:
                logger.warning(f"Invalid token '{token}' attempted to acquire lock for object '{object_id}'.")
        return False

    def release_lock(self, object_id: str):
        """
        Releases the thread lock for a specified user object and generates a new security token by
        hashing the object's UUID, blockchain UUID, and the current timestamp. This mechanism ensures
        that each update operation requires a fresh token, enhancing the security of thread-safe procedures.

        Args:
            object_id (str): The unique identifier of the user object releasing the lock.
        """
        with self.manager_lock:
            lock = self.locks.get(object_id)
            if lock and lock.locked():
                lock.release()
                logger.info(f"Lock released for object '{object_id}'.")
                # Generate a new token after releasing the lock
                blockchain_uuid = str(uuid.uuid4())
                combined_string = f"{object_id}-{blockchain_uuid}-{threading.current_thread().name}"
                new_token = uuid.uuid5(uuid.NAMESPACE_DNS, combined_string).hex
                self.tokens[object_id] = new_token
                logger.info(f"New token generated for object '{object_id}': '{new_token}'.")

    def get_new_token(self, object_id: str) -> str:
        """
        Generates a new security token for a specified user object by hashing its UUID, a new
        blockchain-related UUID, and the current timestamp. This token is essential for authorizing
        future update operations, ensuring that only entities with valid tokens can modify the object's state.

        Args:
            object_id (str): The unique identifier of the user object requesting a new token.

        Returns:
            str: The newly generated security token.
        """
        with self.manager_lock:
            blockchain_uuid = str(uuid.uuid4())
            combined_string = f"{object_id}-{blockchain_uuid}-{threading.current_thread().name}"
            new_token = uuid.uuid5(uuid.NAMESPACE_DNS, combined_string).hex
            self.tokens[object_id] = new_token
            logger.info(f"New token '{new_token}' assigned to object '{object_id}'.")
            return new_token

    def send_message(self, object_id: str, message: Any):
        """
        Sends a message to the specified user object's mailbox, facilitating asynchronous
        communication between different components or threads within the simulation. This
        method ensures that messages are queued securely and can be retrieved in a thread-safe
        manner during update operations.

        Args:
            object_id (str): The unique identifier of the user object receiving the message.
            message (Any): The content of the message to be sent.
        """
        with self.manager_lock:
            if object_id in self.mailboxes:
                self.mailboxes[object_id].append(message)
                logger.info(f"Message sent to object '{object_id}': {message}")
            else:
                logger.error(f"Attempted to send message to unregistered object '{object_id}'.")

    def receive_message(self, object_id: str) -> Any:
        """
        Retrieves the next message from the specified user object's mailbox, if available.
        This method allows user objects to process incoming communications during their update
        operations, ensuring that all messages are handled in a first-in-first-out (FIFO) manner.

        Args:
            object_id (str): The unique identifier of the user object retrieving the message.

        Returns:
            Any: The content of the next message if available, else None.
        """
        with self.manager_lock:
            if object_id in self.mailboxes and self.mailboxes[object_id]:
                message = self.mailboxes[object_id].popleft()
                logger.info(f"Message received by object '{object_id}': {message}")
                return message
            else:
                logger.debug(f"No messages to receive for object '{object_id}'.")
                return None